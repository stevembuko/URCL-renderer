bits == 16
minreg 15
minheap 64000


//camera varibles
.camPos //x, y, and z position of the camera
DW [ 1 -50 -100 ] // <-- adjust the position of the camera here
.camRotation //simplified world to camera space matrix
DW [ 1 0 0 ]
DW [ 0 1 0 ]
DW [ 0 0 1 ]
.camLens //pixels per unit at one unit of distance
DW [ 128 ]  // <-- set this low (1 is good) if you're using orthographic. When using perspective, the larger it is relative to screen size, the narrower the FOV. If this == screen size, you get 90 degrees FOV. It's also worth noting that if this * screen size > @smax, you may run into overflow errors.
.camClipNear //near clipping plane
DW [ 1 ]
.camClipFar //far clipping plane
DW [ 255 ]


@define meshAddr .chair // <-- replace this label with your mesh's name
@define orthographic 0 // <-- 1 = orthographic, 0 = perspective. Make sure to adjust the .camLens value when using orthographic.

//V V paste mesh data here V V

//^ ^ paste mesh data here ^ ^


//active vertices
    .activeTriV1 //x, y, z, u, v
    DW [ 2 2 20  0 0 ]
    .activeTriV2
    DW [ 10 15 30  0 0 ]
    .activeTriV3
    DW [ 15 2 10  0 0 ]
    .tempVert
    DW [ 0 0 0  0 0 ]
    @define x 0
    @define y 1
    @define z 2
    @define u 3
    @define v 4
//end active vertices
    .depthBuffer
        DW [ 0 ] // plus the rest of the heap

//global regs
@define frame r1
@define triIndex r2

//temporary regs 
@define gen1 r15
@define gen2 r14
@define var1 r13
@define var2 r12
@define addr r11
@define temp r10



out %buffer 2
.loop

    imm gen1 0
    in var1 %x
    in var2 %y
    mlt gen2 var1 var2
    .DBLoop
        lstr .depthBuffer gen1 @max
        inc gen1 gen1
    brl .DBLoop gen1 gen2

    out %buffer 1

    cal .drawMesh

    llod var1 .camPos 1
    inc var1 var1
    lstr .camPos 1 var1

    out %buffer 0
jmp .loop


// out %buffer 2
// out %buffer 1
// cal .drawTriangle
// out %buffer 0

hlt

.drawMesh
    imm triIndex 0
    .triLoop
        llod var1 meshAddr 3
        llod var1 var1 -1
        bge .endTriLoop triIndex var1
        
        //get vertex 1
        mlt gen1 triIndex 3
        llod var1 meshAddr 3
        llod gen2 var1 gen1
        mlt gen2 gen2 3

        llod var1 meshAddr 0
        add addr var1 gen2

        llod var1 addr x
        lstr .activeTriV1 x var1
        llod var1 addr y
        lstr .activeTriV1 y var1
        llod var1 addr z
        lstr .activeTriV1 z var1
        llod var1 addr u
        lstr .activeTriV1 u var1
        llod var1 addr v
        lstr .activeTriV1 v var1

        imm addr .activeTriV1
        cal .toScreenSpace
        bnz .triLoopNext clip

        //get vertex 2
        mlt gen1 triIndex 3
        inc gen1 gen1
        llod var1 meshAddr 3
        llod gen2 var1 gen1
        mlt gen2 gen2 3
        llod var1 meshAddr 0
        add addr var1 gen2

        llod var1 addr x
        lstr .activeTriV2 x var1
        llod var1 addr y
        lstr .activeTriV2 y var1
        llod var1 addr z
        lstr .activeTriV2 z var1
        llod var1 addr u
        lstr .activeTriV2 u var1
        llod var1 addr v
        lstr .activeTriV2 v var1

        imm addr .activeTriV2
        cal .toScreenSpace
        bnz .triLoopNext clip

        //get vertex 3
        mlt gen1 triIndex 3
        add gen1 gen1 2
        llod var1 meshAddr 3
        llod gen2 var1 gen1
        mlt gen2 gen2 3
        llod var1 meshAddr 0
        add addr var1 gen2

        llod var1 addr x
        lstr .activeTriV3 x var1
        llod var1 addr y
        lstr .activeTriV3 y var1
        llod var1 addr z
        lstr .activeTriV3 z var1
        llod var1 addr u
        lstr .activeTriV3 u var1
        llod var1 addr v
        lstr .activeTriV3 v var1

        imm addr .activeTriV3
        cal .toScreenSpace
        bnz .triLoopNext clip

        //draw the triangle
        psh triIndex
        psh frame
        cal .drawTriangle
        pop frame
        pop triIndex
        
        .triLoopNext
            inc triIndex triIndex
            jmp .triLoop
    .endTriLoop
ret



//toScreenSpace function
    //description:
        //takes the address of a vertex and converts that vertex into screen space
    //inputs:
        @define activeVertex addr //the address of the vertex to convert to screen space
    //returns:
        //modifies the values stored in the activeVertex memory location
        @define clip r3 //returns 0 if vertice is not clipped and 1 if it is.
    //also uses:
        @define wspX r3 //world space point X
        @define wspY r4 //world space point Y
        @define wspZ r5 //world space point Z
.toScreenSpace
    //set origin to camera
    llod var1 .camPos x
    llod var2 activeVertex x
    sub wspX var2 var1

    llod var1 .camPos y
    llod var2 activeVertex y
    sub wspY var2 var1

    llod var1 .camPos z
    llod var2 activeVertex z
    sub wspZ var2 var1

    //find cam space Z
    llod var1 .camRotation 6
    mlt gen1 var1 wspX
    llod var1 .camRotation 7
    mlt gen2 var1 wspY
    add gen1 gen1 gen2
    llod var1 .camRotation 8
    mlt gen2 var1 wspZ
    add gen1 gen1 gen2

    //if cam space Z is negative or zero, clip.
    lod gen2 .camClipNear
    sbrl .toScreenSpaceClip gen1 gen2
    lod gen2 .camClipFar
    brg .toScreenSpaceClip gen1 gen2

        lstr activeVertex z gen1

        //find cam space X
        llod var1 .camRotation 0
        mlt gen1 var1 wspX
        llod var1 .camRotation 1
        mlt gen2 var1 wspY
        add gen1 gen1 gen2
        llod var1 .camRotation 2
        mlt gen2 var1 wspZ
        add gen1 gen1 gen2
        lstr activeVertex x gen1

        //find cam space Y
        llod var1 .camRotation 3
        mlt gen1 var1 wspX
        llod var1 .camRotation 4
        mlt gen2 var1 wspY
        add gen1 gen1 gen2
        llod var1 .camRotation 5
        mlt gen2 var1 wspZ
        add gen1 gen1 gen2
        lstr activeVertex y gen1

        //convert from cam space to screen coordinates
        lod var1 .camLens
        llod var2 activeVertex z
        
        llod gen1 activeVertex x

        xor gen2 gen1 var1
        mlt gen1 gen1 var1
        xor gen2 gen2 gen1
        brn .toScreenSpaceClip gen2 //if multiplication overflows/gets the sign wrong, clip.

        bnz ~2 orthographic
            sdiv gen1 gen1 var2
        in gen2 %x
        rsh gen2 gen2
        add gen1 gen1 gen2
        lstr activeVertex x gen1

        llod gen1 activeVertex y

        xor gen2 gen1 var1
        mlt gen1 gen1 var1
        xor gen2 gen2 gen1
        brn .toScreenSpaceClip gen2 //if multiplication overflows/gets the sign wrong, clip.

        bnz ~2 orthographic
            sdiv gen1 gen1 var2
        in gen2 %y
        rsh gen2 gen2
        sub gen1 gen2 gen1
        lstr activeVertex y gen1

        imm clip 0 //TODO find a better clipping method.
    ret
    .toScreenSpaceClip
        out %text 'c'
        out %text 'l'
        out %text 'i'
        out %text 'p'
        out %text '\n'
        imm clip 1
    ret
//end toCamSpace


//drawTriangle function
    //description:
        //Draws a triangle from the screen space coordinates of its vertices 
    //inputs:
        //.activeTriV1 memory
        //.activeTriV2 memory
        //.activeTriV3 memory
    //returns:
        //none
    //also uses:
        @define v1 r3
        @define v2 r4
        @define v3 r5
        @define xI r6
        @define yI r7
        @define maxX r8
        //.tempVert memory
.drawTriangle
    imm v1 .activeTriV1
    imm v2 .activeTriV2
    imm v3 .activeTriV3

    //sort vertices by ascending y position
    llod var1 v1 y
    llod var2 v2 y
    sble .sort1End var1 var2
        mov temp v1
        mov v1 v2
        mov v2 temp
    .sort1End

    llod var1 v2 y
    llod var2 v3 y
    sble .sort2End var1 var2
        mov temp v2
        mov v2 v3
        mov v3 temp

        llod var1 v1 y
        llod var2 v2 y
        sble .sort3End var1 var2
            mov temp v1
            mov v1 v2
            mov v2 temp
        .sort3End
    .sort2End


    //find edge cases
    llod var1 v1 y
    llod var2 v2 y
    bre .flatBottomTri var1 var2
    llod var1 v3 y
    bre .flatTopTri var2 var1

    //draw the triangle normally
        
        llod var1 v2 y
        lstr .tempVert y var1

        llod var1 v3 x
        llod var2 v1 x
        sub gen1 var1 var2

        llod var1 v2 y
        llod var2 v1 y
        sub gen2 var1 var2

        mlt gen1 gen1 gen2

        llod var1 v3 y
        sub gen2 var1 var2

        sdiv gen1 gen1 gen2

        llod var1 v1 x
        add gen1 gen1 var1
        lstr .tempVert x gen1


        llod var1 v3 z
        llod var2 v1 z
        sub gen1 var1 var2

        llod var1 v2 y
        llod var2 v1 y
        sub gen2 var1 var2

        mlt gen1 gen1 gen2

        llod var1 v3 y
        sub gen2 var1 var2

        sdiv gen1 gen1 gen2

        llod var1 v1 z
        add gen1 gen1 var1
        lstr .tempVert z gen1


        mov temp v3
        imm v3 .tempVert
        
        llod var1 v2 x
        llod var2 v3 x
        sble .sort4End var1 var2
            mov v3 v2
            imm v2 .tempVert
        .sort4End

        cal .drawFlatTopTri

        mov v1 v2
        mov v2 v3
        mov v3 temp

        cal .drawFlatBottomTri
    ret

    //handle edge cases
    .flatBottomTri
        llod var1 v2 y
        llod var2 v3 y
        bre .line var1 var2

        llod var1 v1 x
        llod var2 v2 x
        sble .sortBottomEnd var1 var2
            mov gen1 v1
            mov v1 v2
            mov v2 gen1
        .sortBottomEnd

        cal .drawFlatBottomTri
    ret

    .flatTopTri
        llod var1 v2 x
        llod var2 v3 x
        sbrl .sortTopEnd var1 var2
            mov gen1 v2
            mov v2 v3
            mov v3 gen1
        .sortTopEnd
        
        cal .drawFlatTopTri
    ret

    .line //TODO add depth
        llod var1 v1 x
        llod var2 v2 x
        sble .lineSort1 var1 var2
            mov temp v1
            mov v1 v2
            mov v2 temp
        .lineSort1
        llod var1 v2 x
        llod var2 v3 x
        sble .lineSort2 var1 var2
            mov temp v2
            mov v2 v3
            mov v3 temp

            llod var1 v1 x
            llod var2 v2 x
            sble .lineSort2 var1 var2
                mov temp v1
                mov v1 v2
                mov v2 temp
        .lineSort2

        llod minX v1 x
        mov xI minX
        llod minDepth v1 z

        llod maxX v3 x
        llod maxDepth v3 z

        llod yI v1 y
        in var1 %y
        bge .endLine yI var1

        brn .endLine maxX

        ssetg gen1 xI 0
        and xI xI gen1

        llod gen1 v1 y
        out %y gen1
        .lineLoop

            sub gen1 xI minX
            sub gen2 maxDepth minDepth
            mlt gen1 gen1 gen2
            sub gen2 maxX minX
            sdiv gen1 gen1 gen2
            add gen1 gen1 minDepth

            in gen2 %x
            mlt gen2 yI gen2
            add gen2 gen2 xI
            //llod var1 .depthBuffer gen2

            bge .FBTriXLoopNext gen1 var1
                lstr .depthBuffer gen2 gen1

                out %x xI
                out %color gen1 //TODO add color system?
            .lineLoopNext
                inc xI xI
        ble .lineLoop xI maxX

    .endLine
    ret

    //drawTriangle helper functions
        //drawFlatBottomTri function
            //description:
                //draws a (portion of a) triangle that's bottom side is flat
            //inputs:
                //v1 address of vertex 1 //must be sorted
                //v2 address of vertex 2
                //v3 address of vertex 3
            //returns:
                //none
            //also uses:
                //xI
                //yI
                //maxX
                @define minX r9
                @define minDepth r1
                @define maxDepth r2
        .drawFlatBottomTri
            llod var1 v3 y
            
            brn .endFBTri var1 //if end coord is before the screen, don't draw the triangle
            llod yI v1 y

            //clamp start and end coords to screen
            ssetg gen1 yI 0
            and yI yI gen1

            in gen1 %y
            dec gen1 gen1

            ble .FBTriMaxY var1 gen1
                mov var1 gen1
            .FBTriMaxY

            //loop through each Y coord in the triangle
            .FBTriYLoop
                //calculate scanline end X coord
                llod var1 v3 x
                llod var2 v2 x
                sub gen1 var1 var2

                llod var1 v2 y
                sub gen2 yI var1

                mlt gen1 gen1 gen2

                llod var2 v3 y
                sub gen2 var2 var1

                sdiv gen1 gen1 gen2

                llod var1 v2 x
                add maxX gen1 var1

                brn .FBTriYLoopNext maxX //if end position is negative, skip this scan line

                //calculate scanline start X coord
                llod var1 v3 x
                llod var2 v1 x
                sub gen2 var1 var2

                llod var1 v1 y
                sub gen1 yI var1

                mlt gen1 gen1 gen2

                llod var2 v3 y
                sub gen2 var2 var1

                sdiv gen1 gen1 gen2

                llod var1 v1 x
                add minX gen1 var1
                mov xI minX

                //calculate scanline start X depth
                llod var1 v3 z
                llod var2 v1 z
                sub gen2 var1 var2

                llod var1 v1 y
                sub gen1 yI var1

                mlt gen1 gen1 gen2

                llod var2 v3 y
                sub gen2 var2 var1

                sdiv gen1 gen1 gen2

                llod var1 v1 z
                add minDepth gen1 var1

                //calculate scanline end X depth
                llod var1 v3 z
                llod var2 v2 z
                sub gen1 var1 var2

                llod var1 v2 y
                sub gen2 yI var1

                mlt gen1 gen1 gen2

                llod var2 v3 y
                sub gen2 var2 var1

                sdiv gen1 gen1 gen2

                llod var1 v2 z
                add maxDepth gen1 var1

                //clamp start and end coords to screen
                ssetg gen1 xI 0
                and xI xI gen1

                in gen1 %x
                dec gen1 gen1
                ble .FBTriMaxX maxX gen1
                    mov maxX gen1
                .FBTriMaxX

                //draw the line
                out %y yI
                .FBTriXLoop

                    sub gen1 xI minX
                    sub gen2 maxDepth minDepth
                    mlt gen1 gen1 gen2
                    sub gen2 maxX minX
                    sdiv gen1 gen1 gen2
                    add gen1 gen1 minDepth

                    in gen2 %x
                    mlt gen2 yI gen2
                    add gen2 gen2 xI
                    llod var1 .depthBuffer gen2
                    bge .FBTriXLoopNext gen1 var1

                        lstr .depthBuffer gen2 gen1

                        out %x xI
                        out %color gen1 //TODO add color system?
                    .FBTriXLoopNext
                        inc xI xI
                ble .FBTriXLoop xI maxX
                
                .FBTriYLoopNext
                inc yI yI
                llod var1 v3 y
            ble .FBTriYLoop yI var1
        .endFBTri
        ret

        //description:
                //draws a (portion of a) triangle that's bottom side is flat
            //inputs:
                //v1 address of vertex 1 //must be sorted
                //v2 address of vertex 2
                //v3 address of vertex 3
            //returns:
                //none
            //also uses:
                //xI
                //yI
                //maxX
        .drawFlatTopTri
            llod var1 v3 y
            brn .endFTTri var1 //if end coord is before the screen, don't draw the triangle

            llod yI v1 y

            //clamp start and end coords to screen
            ssetg gen1 yI 0
            and yI yI gen1

            in gen1 %y
            dec gen1 gen1
            ble .FTTriMaxY var1 gen1
                mov var1 gen1
            .FTTriMaxY

            //loop through each Y coord in the triangle
            .FTTriYLoop
                //calculate end X position
                llod var1 v3 x
                llod var2 v1 x
                sub gen2 var1 var2

                llod var1 v1 y
                sub gen1 yI var1

                mlt gen1 gen1 gen2

                llod var2 v3 y
                sub gen2 var2 var1

                sdiv gen1 gen1 gen2

                llod var1 v1 x
                add maxX gen1 var1

                brn .FTTriYLoopNext maxX //if end X is before the screen, skip this scanline

                //calculate start X position
                llod var1 v2 x
                llod var2 v1 x 
                sub gen2 var1 var2

                llod var1 v1 y
                sub gen1 yI var1

                mlt gen1 gen1 gen2

                llod var2 v2 y
                sub gen2 var2 var1

                sdiv gen1 gen1 gen2

                llod var1 v1 x
                add minX gen1 var1
                mov xI minX

                //calculate start X Depth
                llod var1 v2 z
                llod var2 v1 z 
                sub gen2 var1 var2

                llod var1 v1 y
                sub gen1 yI var1

                mlt gen1 gen1 gen2

                llod var2 v2 y
                sub gen2 var2 var1

                sdiv gen1 gen1 gen2

                llod var1 v1 z
                add minDepth gen1 var1

                //calculate end X depth
                llod var1 v3 z
                llod var2 v1 z
                sub gen2 var1 var2

                llod var1 v1 y
                sub gen1 yI var1

                mlt gen1 gen1 gen2

                llod var2 v3 y
                sub gen2 var2 var1

                sdiv gen1 gen1 gen2

                llod var1 v1 z
                add maxDepth gen1 var1

                //clamp beginning and end X to screen
                ssetg gen1 xI 0
                and xI xI gen1

                in gen1 %x
                dec gen1 gen1
                ble .FTTriMaxX maxX gen1
                    mov maxX gen1
                .FTTriMaxX

                //draw the scanline

                out %y yI
                .FTTriXLoop

                    sub gen1 xI minX
                    sub gen2 maxDepth minDepth
                    mlt gen1 gen1 gen2
                    sub gen2 maxX minX
                    sdiv gen1 gen1 gen2
                    add gen1 gen1 minDepth

                    in gen2 %x
                    mlt gen2 yI gen2
                    add gen2 gen2 xI
                    llod var1 .depthBuffer gen2

                    bge .FTTriXLoopNext gen1 var1

                        lstr .depthBuffer gen2 gen1

                        out %x xI
                        out %color gen1 //TODO add color system?
                    .FTTriXLoopNext
                    inc xI xI
                ble .FTTriXLoop xI maxX

                .FTTriYLoopNext
                    inc yI yI
                    llod var1 v3 y
            ble .FTTriYLoop yI var1
        .endFTTri
        ret
    //end helper functions
//end drawTriangle function