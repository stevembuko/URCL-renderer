bits == 16
minreg 15


//camera varibles
.camPos //x, y, and z position of the camera
DW [ 0 50 -400 ] // <-- adjust the position of the camera here
.camRotation //simplified world to camera space matrix
DW [ 1 0 0 ]
DW [ 0 1 0 ]
DW [ 0 0 1 ]
.camLens //pixels per unit at one unit of distance
DW [ 128 ]  // <-- set this low (1 is good) if you're using orthographic. When using perspective, the larger it is relative to screen size, the narrower the FOV. If this == screen size, you get 90 degrees FOV. It's also worth noting that if this * screen size > @smax, you may run into overflow errors.
.camClipNear //near clipping plane
DW [ 1 ]
.camClipFar //far clipping plane
DW [ 1028 ]


@define meshAddr .bottle // <-- replace this label with your mesh's name
@define fillTriangles 1 // <-- 1 = filled triangles, 0 = vertices only
@define orthographic 0 // <-- 1 = orthographic, 0 = perspective. Make sure to adjust the .camLens value when using orthographic.

//V V paste mesh data here V V

//^ ^ paste mesh data here ^ ^


//active vertices
    .activeTriV1 //x, y, z, u, v
        DW [ 0 0 0  0 0 ]
    .activeTriV2
        DW [ 0 0 0  0 0 ]
    .activeTriV3
        DW [ 0 0 0  0 0 ]
    .tempVert
        DW [ 0 0 0  0 0 ]
    @define x 0
    @define y 1
    @define z 2
    @define u 3
    @define v 4
//end active vertices

//global regs
@define frame r1
@define triIndex r2

//temporary regs 
@define gen1 r15
@define gen2 r14
@define var1 r13
@define var2 r12
@define addr r11
@define temp r10


out %buffer 2
.loop
    out %buffer 1

    cal .drawMesh

    llod var1 .camPos 1
    inc var1 var1
    lstr .camPos 1 var1

    out %buffer 0
//jmp .loop
hlt

.drawMesh
    imm triIndex 0
    .triLoop
        llod var1 meshAddr 3
        llod var1 var1 -1
        bge .endTriLoop triIndex var1
        
        //get vertex 1
        mlt gen1 triIndex 3
        llod var1 meshAddr 3
        llod gen2 var1 gen1
        mlt gen2 gen2 3

        llod var1 meshAddr 0
        add addr var1 gen2

        llod var1 addr x
        lstr .activeTriV1 x var1
        llod var1 addr y
        lstr .activeTriV1 y var1
        llod var1 addr z
        lstr .activeTriV1 z var1
        llod var1 addr u
        lstr .activeTriV1 u var1
        llod var1 addr v
        lstr .activeTriV1 v var1

        imm addr .activeTriV1
        cal .toScreenSpace
        bnz .triLoopNext clip

        //get vertex 2
        mlt gen1 triIndex 3
        inc gen1 gen1
        llod var1 meshAddr 3
        llod gen2 var1 gen1
        mlt gen2 gen2 3
        llod var1 meshAddr 0
        add addr var1 gen2

        llod var1 addr x
        lstr .activeTriV2 x var1
        llod var1 addr y
        lstr .activeTriV2 y var1
        llod var1 addr z
        lstr .activeTriV2 z var1
        llod var1 addr u
        lstr .activeTriV2 u var1
        llod var1 addr v
        lstr .activeTriV2 v var1

        imm addr .activeTriV2
        cal .toScreenSpace
        bnz .triLoopNext clip

        //get vertex 3
        mlt gen1 triIndex 3
        add gen1 gen1 2
        llod var1 meshAddr 3
        llod gen2 var1 gen1
        mlt gen2 gen2 3
        llod var1 meshAddr 0
        add addr var1 gen2

        llod var1 addr x
        lstr .activeTriV3 x var1
        llod var1 addr y
        lstr .activeTriV3 y var1
        llod var1 addr z
        lstr .activeTriV3 z var1
        llod var1 addr u
        lstr .activeTriV3 u var1
        llod var1 addr v
        lstr .activeTriV3 v var1

        imm addr .activeTriV3
        cal .toScreenSpace
        bnz .triLoopNext clip

        //draw vertices
            llod var1 .activeTriV1 x
            out %x var1
            llod var1 .activeTriV1 y
            out %y var1
            out %color 1

            llod var1 .activeTriV2 x
            out %x var1
            llod var1 .activeTriV2 y
            out %y var1
            out %color 1

            llod var1 .activeTriV3 x
            out %x var1
            llod var1 .activeTriV3 y
            out %y var1
            out %color 1
        //end draw vertices

        //draw the triangle
        brz .triLoopNext fillTriangles
        cal .drawTriangle
        
        .triLoopNext
            inc triIndex triIndex
            jmp .triLoop
    .endTriLoop
ret



//toScreenSpace function
    //description:
        //takes the address of a vertex and converts that vertex into screen space
    //inputs:
        @define activeVertex addr //the address of the vertex to convert to screen space
    //returns:
        //modifies the values stored in the activeVertex memory location
        @define clip r3 //returns 0 if vertice is not clipped and 1 if it is.
    //also uses:
        @define wspX r3 //world space point X
        @define wspY r4 //world space point Y
        @define wspZ r5 //world space point Z
.toScreenSpace
    //set origin to camera
    llod var1 .camPos x
    llod var2 activeVertex x
    sub wspX var2 var1

    llod var1 .camPos y
    llod var2 activeVertex y
    sub wspY var2 var1

    llod var1 .camPos z
    llod var2 activeVertex z
    sub wspZ var2 var1

    //find cam space Z
    llod var1 .camRotation 6
    mlt gen1 var1 wspX
    llod var1 .camRotation 7
    mlt gen2 var1 wspY
    add gen1 gen1 gen2
    llod var1 .camRotation 8
    mlt gen2 var1 wspZ
    add gen1 gen1 gen2

    //if cam space Z is negative or zero, clip.
    lod gen2 .camClipNear
    sbrl .toScreenSpaceClip gen1 gen2
    lod gen2 .camClipFar
    brg .toScreenSpaceClip gen1 gen2

        lstr activeVertex z gen1

        //find cam space X
        llod var1 .camRotation 0
        mlt gen1 var1 wspX
        llod var1 .camRotation 1
        mlt gen2 var1 wspY
        add gen1 gen1 gen2
        llod var1 .camRotation 2
        mlt gen2 var1 wspZ
        add gen1 gen1 gen2
        lstr activeVertex x gen1

        //find cam space Y
        llod var1 .camRotation 3
        mlt gen1 var1 wspX
        llod var1 .camRotation 4
        mlt gen2 var1 wspY
        add gen1 gen1 gen2
        llod var1 .camRotation 5
        mlt gen2 var1 wspZ
        add gen1 gen1 gen2
        lstr activeVertex y gen1

        // v v temp v v 
            // llod var1 activeVertex x
            // llod var2 .camPos x
            // sub gen1 var1 var2
            // lstr activeVertex x gen1

            // llod var1 activeVertex y
            // llod var2 .camPos y
            // sub gen1 var1 var2
            // lstr activeVertex y gen1

            // llod var1 activeVertex z
            // llod var2 .camPos z
            // sub gen1 var1 var2
            // lstr activeVertex z gen1
        // ^ ^ temp ^ ^

        //convert from cam space to screen coordinates
        lod var1 .camLens
        llod var2 activeVertex z
        
        llod gen1 activeVertex x

        xor gen2 gen1 var1
        mlt gen1 gen1 var1
        xor gen2 gen2 gen1
        brn .toScreenSpaceClip gen2 //if multiplication overflows/gets the sign wrong, clip.

        bnz ~2 orthographic
            sdiv gen1 gen1 var2
        in gen2 %x
        rsh gen2 gen2
        add gen1 gen1 gen2
        lstr activeVertex x gen1

        llod gen1 activeVertex y

        xor gen2 gen1 var1
        mlt gen1 gen1 var1
        xor gen2 gen2 gen1
        brn .toScreenSpaceClip gen2 //if multiplication overflows/gets the sign wrong, clip.

        bnz ~2 orthographic
            sdiv gen1 gen1 var2
        in gen2 %y
        rsh gen2 gen2
        sub gen1 gen2 gen1
        lstr activeVertex y gen1

        imm clip 0 //TODO find a better clipping method.
    ret
    .toScreenSpaceClip
        out %text 'c'
        out %text 'l'
        out %text 'i'
        out %text 'p'
        out %text '\n'
        imm clip 1
    ret
//end toCamSpace


//drawTriangle function
    //description:
        //Draws a triangle from the screen space coordinates of its vertices 
    //inputs:
        //.activeTriV1 memory
        //.activeTriV2 memory
        //.activeTriV3 memory
    //returns:
        //none
    //also uses:
        @define v1 r3
        @define v2 r4
        @define v3 r5
        @define xI r6
        @define yI r7
        @define maxX r8
        //.tempVert memory
.drawTriangle
    imm v1 .activeTriV1
    imm v2 .activeTriV2
    imm v3 .activeTriV3

    //sort vertices by ascending y position
    llod var1 v1 y
    llod var2 v2 y
    sble .sort1End var1 var2
        mov temp v1
        mov v1 v2
        mov v2 temp
    .sort1End

    llod var1 v2 y
    llod var2 v3 y
    sble .sort2End var1 var2
        mov temp v2
        mov v2 v3
        mov v3 temp

        llod var1 v1 y
        llod var2 v2 y
        sble .sort3End var1 var2
            mov temp v1
            mov v1 v2
            mov v2 temp
        .sort3End
    .sort2End


    //find edge cases
    llod var1 v1 y
    llod var2 v2 y
    bre .flatBottomTri var1 var2
    llod var1 v3 y
    bre .flatTopTri var2 var1

    //draw the triangle normally
        llod var1 v3 x
        llod var2 v1 x
        sub gen1 var1 var2

        llod var1 v2 y
        llod var2 v1 y
        sub gen2 var1 var2

        lstr .tempVert y var1 //store this now because it's already in a register here

        mlt gen1 gen1 gen2

        llod var1 v3 y
        sub gen2 var1 var2

        sdiv gen1 gen1 gen2

        llod var1 v1 x
        add gen1 gen1 var1
        lstr .tempVert x gen1

        mov temp v3
        imm v3 .tempVert
        
        llod var1 v2 x
        llod var2 v3 x
        sble .sort4End var1 var2
            mov v3 v2
            imm v2 .tempVert
        .sort4End

        cal .drawFlatTopTri

        mov v1 v2
        mov v2 v3
        mov v3 temp

        cal .drawFlatBottomTri
    ret

    //handle edge cases
    .flatBottomTri
        llod var1 v2 y
        llod var2 v3 y
        bre .line var1 var2

        llod var1 v1 x
        llod var2 v2 x
        sble .sortBottomEnd var1 var2
            mov gen1 v1
            mov v1 v2
            mov v2 gen1
        .sortBottomEnd

        cal .drawFlatBottomTri
    ret

    .flatTopTri
        llod var1 v2 x
        llod var2 v3 x
        sbrl .sortTopEnd var1 var2
            mov gen1 v2
            mov v2 v3
            mov v3 gen1
        .sortTopEnd
        
        cal .drawFlatTopTri
    ret

    .line
        llod var1 v1 x
        llod var2 v2 x
        sble .lineSort1 var1 var2
            mov xI var2
            mov maxX var1
            jmp .lineSort1End
        .lineSort1
            mov xI var1
            mov maxX var2
        .lineSort1End

        llod var1 v3 x
        sbrl .lineSort2End xI var1
            mov xI var1
            jmp .lineSort3End
        .lineSort2End
        
        sbrg .lineSort3End maxX var1
            mov maxX var1
        .lineSort3End

        brn .endLine maxX

        ssetg gen1 xI 0
        and xI xI gen1

        llod gen1 v1 y
        out %y gen1
        .lineLoop
            out %x xI
            out %color 1 //TODO add color system?
            inc xI xI
        ble .lineLoop xI maxX

    .endLine
    ret

    //drawTriangle helper functions
        //drawFlatBottomTri function
            //description:
                //draws a (portion of a) triangle that's bottom side is flat
            //inputs:
                //v1 address of vertex 1 //must be sorted
                //v2 address of vertex 2
                //v3 address of vertex 3
            //returns:
                //none
            //also uses:
                //xI
                //yI
                //maxX
                @define maxY r9
        .drawFlatBottomTri
            llod maxY v3 y
            
            brn .endFBTri maxY //if end coord is before the screen, don't draw the triangle
            llod yI v1 y

            //clamp start and end coords to screen
            ssetg gen1 yI 0
            and yI yI gen1

            in gen1 %y
            dec gen1 gen1
            ble .FBTriMaxY maxY gen1
                mov maxY gen1
            .FBTriMaxY

            //loop through each Y coord in the triangle
            .FBTriYLoop
                //calculate scanline end X coord
                llod var1 v3 x
                llod var2 v2 x
                sub gen1 var1 var2

                llod var1 v2 y
                sub gen2 yI var1

                mlt gen1 gen1 gen2

                llod var2 v3 y
                sub gen2 var2 var1

                sdiv gen1 gen1 gen2

                llod var1 v2 x
                add maxX gen1 var1

                brn .FBTriYLoopNext maxX //if end position is negative, skip this scan line

                //calculate scanline start X coord
                llod var1 v3 x
                llod var2 v1 x
                sub gen2 var1 var2

                llod var1 v1 y
                sub gen1 yI var1

                mlt gen1 gen1 gen2

                llod var2 v3 y
                sub gen2 var2 var1

                sdiv gen1 gen1 gen2

                llod var1 v1 x
                add xI gen1 var1

                //clamp start and end coords to screen
                ssetg gen1 xI 0
                and xI xI gen1

                in gen1 %x
                dec gen1 gen1
                ble .FBTriMaxX maxX gen1
                    mov maxX gen1
                .FBTriMaxX

                //draw the line
                out %y yI
                .FBTriXLoop
                    out %x xI
                    out %color 1 //TODO add color system?
                    inc xI xI
                ble .FBTriXLoop xI maxX
                
                .FBTriYLoopNext
                inc yI yI
            ble .FBTriYLoop yI maxY
        .endFBTri
        ret

        //description:
                //draws a (portion of a) triangle that's bottom side is flat
            //inputs:
                //v1 address of vertex 1 //must be sorted
                //v2 address of vertex 2
                //v3 address of vertex 3
            //returns:
                //none
            //also uses:
                //xI
                //yI
                //maxX
                //@define maxY r9
        .drawFlatTopTri
            llod maxY v3 y
            brn .endFTTri maxY //if end coord is before the screen, don't draw the triangle

            llod yI v1 y

            //clamp start and end coords to screen
            ssetg gen1 yI 0
            and yI yI gen1

            in gen1 %y
            dec gen1 gen1
            ble .FTTriMaxY maxY gen1
                mov maxY gen1
            .FTTriMaxY

            //loop through each Y coord in the triangle
            .FTTriYLoop
                //calculate end X position
                llod var1 v3 x
                llod var2 v1 x
                sub gen2 var1 var2

                llod var1 v1 y
                sub gen1 yI var1

                mlt gen1 gen1 gen2

                llod var2 v3 y
                sub gen2 var2 var1

                sdiv gen1 gen1 gen2

                llod var1 v1 x
                add maxX gen1 var1

                brn .FTTriYLoopNext maxX //if end X is before the screen, skip this scanline

                //calculate start X position
                llod var1 v2 x
                llod var2 v1 x 
                sub gen2 var1 var2

                llod var1 v1 y
                sub gen1 yI var1

                mlt gen1 gen1 gen2

                llod var2 v2 y
                sub gen2 var2 var1

                sdiv gen1 gen1 gen2

                llod var1 v1 x
                add xI gen1 var1

                //clamp beginning and end X to screen
                ssetg gen1 xI 0
                and xI xI gen1

                in gen1 %x
                dec gen1 gen1
                ble .FTTriMaxX maxX gen1
                    mov maxX gen1
                .FTTriMaxX

                //draw the scanline
                out %y yI
                .FTTriXLoop
                    out %x xI
                    out %color 1 //TODO add color system?
                    inc xI xI
                ble .FTTriXLoop xI maxX

                .FTTriYLoopNext
                    inc yI yI
            ble .FTTriYLoop yI maxY
        .endFTTri
        ret
    //end helper functions
//end drawTriangle function