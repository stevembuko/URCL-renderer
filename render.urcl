bits == 16
minreg 15


//camera varibles
.camPos //x, y, and z position of the camera
DW [ 0 0 -10 ]
.camRotation //simplified world to camera space matrix
DW [ 1 0 0 ]
DW [ 0 1 0 ]
DW [ 0 0 1 ]
.camLens //pixels per unit at one unit of distance
DW [ 64 ]
.camClipNear //near clipping plane
DW [ 1 ]
.camClipFar //far clipping plane
DW [ 127 ]

//mesh variables
.meshNumTris
    DW [ 12 ]
.meshTris // vertex 1 index, vertex 2 index, vertex 3 index
    DW [ 7 4 5 ] // 0
    DW [ 7 5 6 ] // 1
    DW [ 4 0 1 ] // 2
    DW [ 4 1 5 ] // 3
    DW [ 0 3 2 ] // 4
    DW [ 0 2 1 ] // 5
    DW [ 3 7 6 ] // 6
    DW [ 3 6 2 ] // 7
    DW [ 5 1 2 ] // 8
    DW [ 5 2 6 ] // 9
    DW [ 4 0 3 ] // 10
    DW [ 4 3 7 ] // 11
//end meshTris
.meshVertices // vertex x, vertex y, vertex z
    DW [ 2 -2 -2 ] // 0
    DW [ 2  2 -2 ] // 1
    DW [-2  2 -2 ] // 2
    DW [-2 -2 -2 ] // 3
    DW [ 2 -2  2 ] // 4
    DW [ 2  2  2 ] // 5
    DW [-2  2  2 ] // 6
    DW [-2 -2  2 ] // 7
//end meshVertices
.meshTexTris // vertex 1 index, vertex 2 index, vertex 3 index
    DW [ 0 3 2 ] // 0
    DW [ 0 2 1 ] // 1
    DW [ 0 3 2 ] // 2
    DW [ 0 2 1 ] // 3
    DW [ 0 3 2 ] // 4
    DW [ 0 2 1 ] // 5
    DW [ 0 3 2 ] // 6
    DW [ 0 2 1 ] // 7
    DW [ 0 3 2 ] // 8
    DW [ 0 2 1 ] // 9
    DW [ 0 3 2 ] // 10
    DW [ 0 2 1 ] // 11
//end meshTexTris
.meshTexCoords // vertex u, vertex v
    DW [ 0 0 ] // 0
    DW [ 0 7 ] // 1
    DW [ 7 7 ] // 2
    DW [ 7 0 ] // 3
//end meshTexCoords
.meshTextureSize //width, height
    DW [ 8 8 ]
.meshTexture
    DW [ 3 3 3 3 3 3 3 3 ]
    DW [ 3 3 3 3 3 3 3 3 ]
    DW [ 3 3 3 4 3 3 4 3 ]
    DW [ 4 3 4 4 3 4 4 4 ]
    DW [ 4 4 5 4 4 4 4 4 ]
    DW [ 4 4 4 4 4 4 4 5 ]
    DW [ 4 4 4 4 4 4 4 4 ]
    DW [ 4 4 4 5 4 4 4 4 ]
//end meshTexture

//active vertices
    .activeTriV1 //x, y, z, u, v
        DW [ 0 0 0  0 0 ]
    .activeTriV2
        DW [ 0 0 0  0 0 ]
    .activeTriV3
        DW [ 0 0 0  0 0 ]
    .tempVert
        DW [ 0 0 0  0 0 ]
    @define x 0
    @define y 1
    @define z 2
    @define u 3
    @define v 4
//end active vertices

//global regs
@define frame r1
@define triIndex r2

//temporary regs 
@define gen1 r15
@define gen2 r14
@define var1 r13
@define var2 r12
@define addr r11
@define temp r10


out %buffer 2
imm frame -8
.animLoop
    out %wait 100
    out %buffer 1

    lstr .camPos 0 frame

    imm triIndex 0
    .triLoop
        lod var1 .meshNumTris
        bge .endTriLoop triIndex var1
        
        //get vertex 1
        mlt gen1 triIndex 3
        llod gen2 .meshTris gen1
        mlt gen2 gen2 3
        add addr .meshVertices gen2

        llod var1 addr x
        lstr .activeTriV1 x var1
        llod var1 addr y
        lstr .activeTriV1 y var1
        llod var1 addr z
        lstr .activeTriV1 z var1
        llod var1 addr u
        lstr .activeTriV1 u var1
        llod var1 addr v
        lstr .activeTriV1 v var1

        imm addr .activeTriV1
        cal .toScreenSpace
        bnz .triLoopNext clip

        //get vertex 2
        mlt gen1 triIndex 3
        inc gen1 gen1
        llod gen2 .meshTris gen1
        mlt gen2 gen2 3
        add addr .meshVertices gen2

        llod var1 addr x
        lstr .activeTriV2 x var1
        llod var1 addr y
        lstr .activeTriV2 y var1
        llod var1 addr z
        lstr .activeTriV2 z var1
        llod var1 addr u
        lstr .activeTriV2 u var1
        llod var1 addr v
        lstr .activeTriV2 v var1

        imm addr .activeTriV2
        cal .toScreenSpace
        bnz .triLoopNext clip

        //get vertex 3
        mlt gen1 triIndex 3
        add gen1 gen1 2
        llod gen2 .meshTris gen1
        mlt gen2 gen2 3
        add addr .meshVertices gen2

        llod var1 addr x
        lstr .activeTriV3 x var1
        llod var1 addr y
        lstr .activeTriV3 y var1
        llod var1 addr z
        lstr .activeTriV3 z var1
        llod var1 addr u
        lstr .activeTriV3 u var1
        llod var1 addr v
        lstr .activeTriV3 v var1

        imm addr .activeTriV3
        cal .toScreenSpace
        bnz .triLoopNext clip

        //draw the triangle
        cal .drawTriangle
        
        .triLoopNext
            inc triIndex triIndex
            jmp .triLoop
    .endTriLoop
    
    out %buffer 0

    inc frame frame

    in r0 %wait
sble .animLoop frame 8
hlt




//toScreenSpace function
    //description:
        //takes the address of a vertex and converts that vertex into screen space
    //inputs:
        @define activeVertex addr //the address of the vertex to convert to screen space
    //returns:
        //modifies the values stored in the activeVertex memory location
        @define clip r3 //returns 0 if vertice is not clipped and 1 if it is.
    //also uses:
        @define wspX r3 //world space point X
        @define wspY r4 //world space point Y
        @define wspZ r5 //world space point Z
.toScreenSpace
    //set origin to camera
    llod var1 .camPos x
    llod var2 activeVertex x
    sub wspX var2 var1

    llod var1 .camPos y
    llod var2 activeVertex y
    sub wspY var2 var1

    llod var1 .camPos z
    llod var2 activeVertex z
    sub wspZ var2 var1

    //find cam space Z
    llod var1 .camRotation 6
    mlt gen1 var1 wspX
    llod var1 .camRotation 7
    mlt gen2 var1 wspY
    add gen1 gen1 gen2
    llod var1 .camRotation 8
    mlt gen2 var1 wspZ
    add gen1 gen1 gen2

    //if cam space Z is negative or zero, clip.
    lod gen2 .camClipNear
    sbrl .toScreenSpaceClip gen1 gen2
    lod gen2 .camClipFar
    brg .toScreenSpaceClip gen1 gen2

        lstr activeVertex z gen1

        //find cam space X
        llod var1 .camRotation 0
        mlt gen1 var1 wspX
        llod var1 .camRotation 1
        mlt gen2 var1 wspY
        add gen1 gen1 gen2
        llod var1 .camRotation 2
        mlt gen2 var1 wspZ
        add gen1 gen1 gen2
        lstr activeVertex x gen1

        //find cam space Y
        llod var1 .camRotation 3
        mlt gen1 var1 wspX
        llod var1 .camRotation 4
        mlt gen2 var1 wspY
        add gen1 gen1 gen2
        llod var1 .camRotation 5
        mlt gen2 var1 wspZ
        add gen1 gen1 gen2
        lstr activeVertex y gen1


        //convert from cam space to screen coordinates
        lod var1 .camLens
        llod var2 activeVertex z
        
        llod gen1 activeVertex x
        mlt gen1 gen1 var1
        sdiv gen1 gen1 var2
        in gen2 %x
        rsh gen2 gen2
        add gen1 gen1 gen2
        lstr activeVertex x gen1

        llod gen1 activeVertex y
        mlt gen1 gen1 var1
        sdiv gen1 gen1 var2
        in gen2 %y
        rsh gen2 gen2
        sub gen1 gen2 gen1
        lstr activeVertex y gen1

        imm clip 0 //TODO find a better clipping method. Probably depth-based per-pixel.
    ret
    .toScreenSpaceClip
        out %text 'c'
        out %text 'l'
        out %text 'i'
        out %text 'p'
        out %text '\n'
        imm clip 1
    ret
//end toCamSpace


//drawTriangle function
    //description:
        //Draws a triangle from the screen space coordinates of its vertices 
    //inputs:
        //.activeTriV1 memory
        //.activeTriV2 memory
        //.activeTriV3 memory
    //returns:
        //none
    //also uses:
        @define v1 r3
        @define v2 r4
        @define v3 r5
        @define xI r6
        @define yI r7
        @define maxX r8
        //.tempVert memory
.drawTriangle
    imm v1 .activeTriV1
    imm v2 .activeTriV2
    imm v3 .activeTriV3

    //sort vertices by ascending y position
    llod var1 v1 y
    llod var2 v2 y
    sble .sort1End var1 var2
        mov temp v1
        mov v1 v2
        mov v2 temp
    .sort1End

    llod var1 v2 y
    llod var2 v3 y
    sble .sort2End var1 var2
        mov temp v2
        mov v2 v3
        mov v3 temp

        llod var1 v1 y
        llod var2 v2 y
        sble .sort3End var1 var2
            mov temp v1
            mov v1 v2
            mov v2 temp
        .sort3End
    .sort2End


    //find edge cases
    llod var1 v1 y
    llod var2 v2 y
    bre .flatBottomTri var1 var2
    llod var1 v3 y
    bre .flatTopTri var2 var1

    //draw the triangle normally
        //TODO the code to handle non-edge cases

        llod var1 v3 x
        llod var2 v1 x
        sub gen1 var1 var2

        llod var1 v2 y
        llod var2 v1 y
        sub gen2 var1 var2

        lstr .tempVert y var1 //store this now because it's already in a register here

        mlt gen1 gen1 gen2

        llod var1 v3 y
        sub gen2 var1 var2

        sdiv gen1 gen1 gen2

        llod var1 v1 x
        add gen1 gen1 var1
        lstr .tempVert x gen1

        mov temp v3
        imm v3 .tempVert
        
        llod var1 v2 x
        llod var2 v3 x
        sble .sort4End var1 var2
            mov v3 v2
            imm v2 .tempVert
        .sort4End

        cal .drawFlatTopTri

        mov v1 v2
        mov v2 v3
        mov v3 temp

        cal .drawFlatBottomTri
    ret

    //handle edge cases
    .flatBottomTri
        llod var1 v2 y
        llod var2 v3 y
        bre .line var1 var2

        llod var1 v1 x
        llod var2 v2 x
        sble .sortBottomEnd var1 var2
            mov gen1 v1
            mov v1 v2
            mov v2 gen1
        .sortBottomEnd

        cal .drawFlatBottomTri
    ret

    .flatTopTri
        llod var1 v2 x
        llod var2 v3 x
        sbrl .sortTopEnd var1 var2
            mov gen1 v2
            mov v2 v3
            mov v3 gen1
        .sortTopEnd
        
        cal .drawFlatTopTri
    ret

    .line
        llod var1 v1 x
        llod var2 v2 x
        sble .lineSort1 var1 var2
            mov xI var2
            mov maxX var1
            jmp .lineSort1End
        .lineSort1
            mov xI var1
            mov maxX var2
        .lineSort1End

        llod var1 v3 x
        sbrl .lineSort2End xI var1
            mov xI var1
            jmp .lineSort3End
        .lineSort2End
        
        sbrg .lineSort3End maxX var1
            mov maxX var1
        .lineSort3End

        brn .endLine maxX

        ssetg gen1 xI 0
        and xI xI gen1

        llod gen1 v1 y
        out %y gen1
        .lineLoop
            out %x xI
            out %color 1 //TODO add color system?
            inc xI xI
        ble .lineLoop xI maxX

    .endLine
    ret

    //drawTriangle helper functions
        //drawFlatBottomTri function
            //description:
                //draws a (portion of a) triangle that's bottom side is flat
            //inputs:
                //v1 address of vertex 1 //must be sorted
                //v2 address of vertex 2
                //v3 address of vertex 3
            //returns:
                //none
            //also uses:
                //xI
                //yI
                //maxX
                @define maxY r9
        .drawFlatBottomTri
            llod maxY v3 y
            
            brn .endFBTri maxY //if end coord is before the screen, don't draw the triangle
            llod yI v1 y

            //clamp start and end coords to screen
            ssetg gen1 yI 0
            and yI yI gen1

            in gen1 %y
            dec gen1 gen1
            ble .FBTriMaxY maxY gen1
                mov maxY gen1
            .FBTriMaxY

            //loop through each Y coord in the triangle
            .FBTriYLoop
                //calculate scanline end X coord
                llod var1 v3 x
                llod var2 v2 x
                sub gen1 var1 var2

                llod var1 v2 y
                sub gen2 yI var1

                mlt gen1 gen1 gen2

                llod var2 v3 y
                sub gen2 var2 var1

                sdiv gen1 gen1 gen2

                llod var1 v2 x
                add maxX gen1 var1

                brn .FBTriYLoopNext maxX //if end position is negative, skip this scan line

                //calculate scanline start X coord
                llod var1 v3 x
                llod var2 v1 x
                sub gen2 var1 var2

                llod var1 v1 y
                sub gen1 yI var1

                mlt gen1 gen1 gen2

                llod var2 v3 y
                sub gen2 var2 var1

                sdiv gen1 gen1 gen2

                llod var1 v1 x
                add xI gen1 var1

                //clamp start and end coords to screen
                ssetg gen1 xI 0
                and xI xI gen1

                in gen1 %x
                dec gen1 gen1
                ble .FBTriMaxX maxX gen1
                    mov maxX gen1
                .FBTriMaxX

                //draw the line
                out %y yI
                .FBTriXLoop
                    out %x xI
                    out %color 1 //TODO add color system?
                    inc xI xI
                ble .FBTriXLoop xI maxX
                
                .FBTriYLoopNext
                inc yI yI
            ble .FBTriYLoop yI maxY
        .endFBTri
        ret

        //description:
                //draws a (portion of a) triangle that's bottom side is flat
            //inputs:
                //v1 address of vertex 1 //must be sorted
                //v2 address of vertex 2
                //v3 address of vertex 3
            //returns:
                //none
            //also uses:
                //xI
                //yI
                //maxX
                //@define maxY r9
        .drawFlatTopTri
            llod maxY v3 y
            brn .endFTTri maxY //if end coord is before the screen, don't draw the triangle

            llod yI v1 y

            //clamp start and end coords to screen
            ssetg gen1 yI 0
            and yI yI gen1

            in gen1 %y
            dec gen1 gen1
            ble .FTTriMaxY maxY gen1
                mov maxY gen1
            .FTTriMaxY

            //loop through each Y coord in the triangle
            .FTTriYLoop
                //calculate end X position
                llod var1 v3 x
                llod var2 v1 x
                sub gen2 var1 var2

                llod var1 v1 y
                sub gen1 yI var1

                mlt gen1 gen1 gen2

                llod var2 v3 y
                sub gen2 var2 var1

                sdiv gen1 gen1 gen2

                llod var1 v1 x
                add maxX gen1 var1

                brn .FTTriYLoopNext maxX //if end X is before the screen, skip this scanline

                //calculate start X position
                llod var1 v2 x
                llod var2 v1 x 
                sub gen2 var1 var2

                llod var1 v1 y
                sub gen1 yI var1

                mlt gen1 gen1 gen2

                llod var2 v2 y
                sub gen2 var2 var1

                sdiv gen1 gen1 gen2

                llod var1 v1 x
                add xI gen1 var1

                //clamp beginning and end X to screen
                ssetg gen1 xI 0
                and xI xI gen1

                in gen1 %x
                dec gen1 gen1
                ble .FTTriMaxX maxX gen1
                    mov maxX gen1
                .FTTriMaxX

                //draw the scanline
                out %y yI
                .FTTriXLoop
                    out %x xI
                    out %color 1 //TODO add color system?
                    inc xI xI
                ble .FTTriXLoop xI maxX

                .FTTriYLoopNext
                    inc yI yI
            ble .FTTriYLoop yI maxY
        .endFTTri
        ret
    //end helper functions
//end drawTriangle function